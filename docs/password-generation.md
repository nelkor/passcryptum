# Алгоритм генерации паролей

Здесь мы рассмотрим алгоритм генерации паролей, используемый в Passcryptum.
Чтобы понять его на глубоком уровне, вам придётся изучить фрагменты кода,
написанные на языке JavaScript. Если вы не ставите себе цель понять все нюансы,
будет достаточно просто прочитать текстовое описание.

Также рекомендуем попробовать вставить в консоль браузера все фрагменты кода
из этой статьи и увидеть результат. Вы можете изменить значения исходных данных
в первом фрагменте кода на свои и убедиться в том, что алгоритм сгенерирует
точно такой же пароль, какой сгенерирует приложение Passcryptum
с такими же исходными данными.

```javascript
const originPassword = '123456'
const serviceName = 'github.com'
const login = 'nelkor'
const version = 1
const length = 20
const useSymbols = true
```

## Исходная энтропия

Всё начинается тогда, когда мы вводим исходный пароль. Приложение вычисляет
буфер данных длиной 128 байт криптографическим алгоритмом PBKDF2. Этот алгоритм
обладает настраиваемой сложностью — можно указать количество итерацией
перемешивания данных, после которого будет взят результат.

Для исходной энтропии количество итераций составляет 262144. Это довольно много
и это усложнит работу тем, кто будет пытаться подобрать чужой исходный пароль
методом грубой силы. Впрочем, мы не можем увеличивать это число бесконечно,
потому что иначе пользователи слабых устройств столкнутся с задержкой при входе
в систему.

```javascript
const originBuffer = new TextEncoder().encode(originPassword).buffer

Promise.all([
  crypto.subtle.importKey('raw', originBuffer, 'PBKDF2', false, ['deriveBits']),
  crypto.subtle.digest('SHA-256', originBuffer),
])
  .then(([key, salt]) =>
    crypto.subtle.deriveBits(
      {
        name: 'PBKDF2',
        hash: 'SHA-512',
        salt,
        iterations: 262144,
      },
      key,
      1024
    )
  )
  .then(result => {
    window.keyBufferFromOriginPassword = result
  })
```

Этот буфер применяется для разных целей, нас же интересует лишь конкретная его
часть, которая принимает непосредственное участие в генерации паролей.

```javascript
const entropyBuffer = keyBufferFromOriginPassword.slice(8, 80)
```

## Параметры генерации

Все остальные (кроме исходного пароля) параметры, влияющие на генерацию пароля
к аккаунту, необходимо объединить в одну строку через запятую в определённом порядке.

```javascript
const paramsString = [login, length, version, useSymbols, serviceName].join()
// например, 'nelkor,20,1,true,github.com'
```

## Объединение буферов

Исходную энтропию объединяем с буфером строки параметров.

```javascript
const paramsBuffer = new TextEncoder().encode(paramsString).buffer
const unitedBytesLength = entropyBuffer.byteLength + paramsBuffer.byteLength
const unitedBytes = new Uint8Array(unitedBytesLength)

unitedBytes.set(new Uint8Array(entropyBuffer), 0)
unitedBytes.set(new Uint8Array(paramsBuffer), entropyBuffer.byteLength)

const mergedBuffer = unitedBytes.buffer
```

## Энтропия пароля

Перемешиваем данные из объединённого буфера алгоритмом PBKDF2, на этот раз
количество итераций всего лишь 16, а длина ключа 64 байта.

```javascript
Promise.all([
  crypto.subtle.importKey('raw', mergedBuffer, 'PBKDF2', false, ['deriveBits']),
  crypto.subtle.digest('SHA-256', mergedBuffer),
])
  .then(([key, salt]) =>
    crypto.subtle.deriveBits(
      {
        name: 'PBKDF2',
        hash: 'SHA-512',
        salt,
        iterations: 16,
      },
      key,
      512
    )
  )
  .then(result => {
    window.passwordEntropyBuffer = result
  })
```

## Зёрна

Одно зёрнышко — это число от 0 до 65535. И нам их нужно столько,
сколько мы хотим символов в пароле. Берутся они из энтропии пароля: по два байта
на зёрнышко. Остальные выбрасываем.

```javascript
const seeds = Array.from(new Uint16Array(passwordEntropyBuffer, 0, length))
```

## Набор символов

Passcryptum гарантирует, что в полученных паролях будет встречаться хотя бы одна
цифра, хотя бы одна строчная буква латинского алфавита и хотя бы одна прописная
буква латинского алфавита. Если для сервиса включена галочка
"использовать специальные символы", то также гарантируется наличие в результате
хотя бы одного специального символа.

Достигается это использованием набора символов, который состоит из трёх частей:

```javascript
const charset = [
  'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  'abcdefghijklmnopqrstuvwxyz',
  '0123456789',
]
```

Если мы используем специальные символы, то их множество дополнительно включается
в набор символов.

```javascript
if (useSymbols) {
  charset.push('`!@#$%^&*()-_=+{[]};:"|/.,<>')
}
```

Из отдельных групп символов мы сможем брать гарантированных представителей:
прописную букву, строчную букву, цифру и специальный символ. Остальные символы
в пароле должны быть абсолютно случайными и будут взяты из объединённого набора.

```javascript
const charUnion = charset.join('')
```

## Stringification of the entropy

Каждый символ в пароле происходит от остатка от деления зерна на размер группы
символов. Группа символов может представлять собой как отдельную часть набора
символов (например, десять цифр), так и весь объединённый набор символов.
Остаток от деления используется в качестве индекса для взятия символа из группы.

Первые 3 или 4 (в зависимости от использования специальных символов) зерна мы
превращаем таким образом в представителей отдельных групп символов. Остальные
зёрна превращаются в случайные символы из объединённого набора.

```javascript
const seedsLetters = seeds.map((seed, index) => {
  const letters = charset[index] || charUnion
  const char = letters.charAt(seed % letters.length)

  return { char, seed }
})
```

Мы получили символы, которые войдут в пароль. Однако, гарантированные
представители групп находятся на первых позициях, что делает пароль чуть более
предсказуемым. Чтобы избавиться от этого эффекта, мы сортируем готовые символы
по возрастанию значения зёрен, из которых они были получены.

```javascript
seedsLetters
  .sort((a, b) => a.seed - b.seed)
  .map(({ char }) => char)
  .join('')
```

Если вы использовали те же исходные данные, которые указаны в начале
этой статьи, то вы получили такой же пароль: `%wBF.hkoq;kT%0UmuUy2`.

## Итог

Passcryptum не делает ничего сверхъестественного, генерация паролей базируется
на математических операциях.

Даже если по какой-то причине приложение вдруг исчезнет, все пароли можно будет
восстановить вручную. Но вручную генерировать пароли слишком долго, а интерфейс
приложения Passcryptum выполнит все нужные операции за долю секунды.
